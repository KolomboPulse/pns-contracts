{
  "language": "Solidity",
  "sources": {
    "contracts/tellor/IERC2362.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\n/**\n * @dev EIP2362 Interface for pull oracles\n * https://github.com/tellor-io/EIP-2362\n */\ninterface IERC2362 {\n    /**\n     * @dev Exposed function pertaining to EIP standards\n     * @param _id bytes32 ID of the query\n     * @return int,uint,uint returns the value, timestamp, and status code of query\n     */\n    function valueFor(\n        bytes32 _id\n    ) external view returns (int256, uint256, uint256);\n}\n"
    },
    "contracts/tellor/IMappingContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IMappingContract {\n    function getTellorID(bytes32 _id) external view returns (bytes32);\n}\n"
    },
    "contracts/tellor/ITellor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\ninterface ITellor {\n    //Controller\n    function addresses(bytes32) external view returns (address);\n\n    function uints(bytes32) external view returns (uint256);\n\n    function burn(uint256 _amount) external;\n\n    function changeDeity(address _newDeity) external;\n\n    function changeOwner(address _newOwner) external;\n\n    function changeUint(bytes32 _target, uint256 _amount) external;\n\n    function migrate() external;\n\n    function mint(address _reciever, uint256 _amount) external;\n\n    function init() external;\n\n    function getAllDisputeVars(\n        uint256 _disputeId\n    )\n        external\n        view\n        returns (\n            bytes32,\n            bool,\n            bool,\n            bool,\n            address,\n            address,\n            address,\n            uint256[9] memory,\n            int256\n        );\n\n    function getDisputeIdByDisputeHash(\n        bytes32 _hash\n    ) external view returns (uint256);\n\n    function getDisputeUintVars(\n        uint256 _disputeId,\n        bytes32 _data\n    ) external view returns (uint256);\n\n    function getLastNewValueById(\n        uint256 _requestId\n    ) external view returns (uint256, bool);\n\n    function retrieveData(\n        uint256 _requestId,\n        uint256 _timestamp\n    ) external view returns (uint256);\n\n    function getNewValueCountbyRequestId(\n        uint256 _requestId\n    ) external view returns (uint256);\n\n    function getAddressVars(bytes32 _data) external view returns (address);\n\n    function getUintVar(bytes32 _data) external view returns (uint256);\n\n    function totalSupply() external view returns (uint256);\n\n    function name() external pure returns (string memory);\n\n    function symbol() external pure returns (string memory);\n\n    function decimals() external pure returns (uint8);\n\n    function isMigrated(address _addy) external view returns (bool);\n\n    function allowance(\n        address _user,\n        address _spender\n    ) external view returns (uint256);\n\n    function allowedToTrade(\n        address _user,\n        uint256 _amount\n    ) external view returns (bool);\n\n    function approve(address _spender, uint256 _amount) external returns (bool);\n\n    function approveAndTransferFrom(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) external returns (bool);\n\n    function balanceOf(address _user) external view returns (uint256);\n\n    function balanceOfAt(\n        address _user,\n        uint256 _blockNumber\n    ) external view returns (uint256);\n\n    function transfer(\n        address _to,\n        uint256 _amount\n    ) external returns (bool success);\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) external returns (bool success);\n\n    function depositStake() external;\n\n    function requestStakingWithdraw() external;\n\n    function withdrawStake() external;\n\n    function changeStakingStatus(address _reporter, uint256 _status) external;\n\n    function slashReporter(address _reporter, address _disputer) external;\n\n    function getStakerInfo(\n        address _staker\n    ) external view returns (uint256, uint256);\n\n    function getTimestampbyRequestIDandIndex(\n        uint256 _requestId,\n        uint256 _index\n    ) external view returns (uint256);\n\n    function getNewCurrentVariables()\n        external\n        view\n        returns (bytes32 _c, uint256[5] memory _r, uint256 _d, uint256 _t);\n\n    function getNewValueCountbyQueryId(\n        bytes32 _queryId\n    ) external view returns (uint256);\n\n    function getTimestampbyQueryIdandIndex(\n        bytes32 _queryId,\n        uint256 _index\n    ) external view returns (uint256);\n\n    function retrieveData(\n        bytes32 _queryId,\n        uint256 _timestamp\n    ) external view returns (bytes memory);\n\n    //Governance\n    enum VoteResult {\n        FAILED,\n        PASSED,\n        INVALID\n    }\n\n    function setApprovedFunction(bytes4 _func, bool _val) external;\n\n    function beginDispute(bytes32 _queryId, uint256 _timestamp) external;\n\n    function delegate(address _delegate) external;\n\n    function delegateOfAt(\n        address _user,\n        uint256 _blockNumber\n    ) external view returns (address);\n\n    function executeVote(uint256 _disputeId) external;\n\n    function proposeVote(\n        address _contract,\n        bytes4 _function,\n        bytes calldata _data,\n        uint256 _timestamp\n    ) external;\n\n    function tallyVotes(uint256 _disputeId) external;\n\n    function governance() external view returns (address);\n\n    function updateMinDisputeFee() external;\n\n    function verify() external pure returns (uint256);\n\n    function vote(\n        uint256 _disputeId,\n        bool _supports,\n        bool _invalidQuery\n    ) external;\n\n    function voteFor(\n        address[] calldata _addys,\n        uint256 _disputeId,\n        bool _supports,\n        bool _invalidQuery\n    ) external;\n\n    function getDelegateInfo(\n        address _holder\n    ) external view returns (address, uint256);\n\n    function isFunctionApproved(bytes4 _func) external view returns (bool);\n\n    function isApprovedGovernanceContract(\n        address _contract\n    ) external returns (bool);\n\n    function getVoteRounds(\n        bytes32 _hash\n    ) external view returns (uint256[] memory);\n\n    function getVoteCount() external view returns (uint256);\n\n    function getVoteInfo(\n        uint256 _disputeId\n    )\n        external\n        view\n        returns (\n            bytes32,\n            uint256[9] memory,\n            bool[2] memory,\n            VoteResult,\n            bytes memory,\n            bytes4,\n            address[2] memory\n        );\n\n    function getDisputeInfo(\n        uint256 _disputeId\n    ) external view returns (uint256, uint256, bytes memory, address);\n\n    function getOpenDisputesOnId(\n        bytes32 _queryId\n    ) external view returns (uint256);\n\n    function didVote(\n        uint256 _disputeId,\n        address _voter\n    ) external view returns (bool);\n\n    //Oracle\n    function getReportTimestampByIndex(\n        bytes32 _queryId,\n        uint256 _index\n    ) external view returns (uint256);\n\n    function getValueByTimestamp(\n        bytes32 _queryId,\n        uint256 _timestamp\n    ) external view returns (bytes memory);\n\n    function getBlockNumberByTimestamp(\n        bytes32 _queryId,\n        uint256 _timestamp\n    ) external view returns (uint256);\n\n    function getReportingLock() external view returns (uint256);\n\n    function getReporterByTimestamp(\n        bytes32 _queryId,\n        uint256 _timestamp\n    ) external view returns (address);\n\n    function reportingLock() external view returns (uint256);\n\n    function removeValue(bytes32 _queryId, uint256 _timestamp) external;\n\n    function getTipsByUser(address _user) external view returns (uint256);\n\n    function tipQuery(\n        bytes32 _queryId,\n        uint256 _tip,\n        bytes memory _queryData\n    ) external;\n\n    function submitValue(\n        bytes32 _queryId,\n        bytes calldata _value,\n        uint256 _nonce,\n        bytes memory _queryData\n    ) external;\n\n    function burnTips() external;\n\n    function changeReportingLock(uint256 _newReportingLock) external;\n\n    function getReportsSubmittedByAddress(\n        address _reporter\n    ) external view returns (uint256);\n\n    function changeTimeBasedReward(uint256 _newTimeBasedReward) external;\n\n    function getReporterLastTimestamp(\n        address _reporter\n    ) external view returns (uint256);\n\n    function getTipsById(bytes32 _queryId) external view returns (uint256);\n\n    function getTimeBasedReward() external view returns (uint256);\n\n    function getTimestampCountById(\n        bytes32 _queryId\n    ) external view returns (uint256);\n\n    function getTimestampIndexByTimestamp(\n        bytes32 _queryId,\n        uint256 _timestamp\n    ) external view returns (uint256);\n\n    function getCurrentReward(\n        bytes32 _queryId\n    ) external view returns (uint256, uint256);\n\n    function getCurrentValue(\n        bytes32 _queryId\n    ) external view returns (bytes memory);\n\n    function getDataBefore(\n        bytes32 _queryId,\n        uint256 _timestamp\n    )\n        external\n        view\n        returns (\n            bool _ifRetrieve,\n            bytes memory _value,\n            uint256 _timestampRetrieved\n        );\n\n    function getTimeOfLastNewValue() external view returns (uint256);\n\n    function depositStake(uint256 _amount) external;\n\n    function requestStakingWithdraw(uint256 _amount) external;\n\n    //Test functions\n    function changeAddressVar(bytes32 _id, address _addy) external;\n\n    //parachute functions\n    function killContract() external;\n\n    function migrateFor(address _destination, uint256 _amount) external;\n\n    function rescue51PercentAttack(address _tokenHolder) external;\n\n    function rescueBrokenDataReporting() external;\n\n    function rescueFailedUpdate() external;\n\n    //Tellor 360\n    function addStakingRewards(uint256 _amount) external;\n\n    function _sliceUint(\n        bytes memory _b\n    ) external pure returns (uint256 _number);\n\n    function claimOneTimeTip(\n        bytes32 _queryId,\n        uint256[] memory _timestamps\n    ) external;\n\n    function claimTip(\n        bytes32 _feedId,\n        bytes32 _queryId,\n        uint256[] memory _timestamps\n    ) external;\n\n    function fee() external view returns (uint256);\n\n    function feedsWithFunding(uint256) external view returns (bytes32);\n\n    function fundFeed(\n        bytes32 _feedId,\n        bytes32 _queryId,\n        uint256 _amount\n    ) external;\n\n    function getCurrentFeeds(\n        bytes32 _queryId\n    ) external view returns (bytes32[] memory);\n\n    function getCurrentTip(bytes32 _queryId) external view returns (uint256);\n\n    function getDataAfter(\n        bytes32 _queryId,\n        uint256 _timestamp\n    ) external view returns (bytes memory _value, uint256 _timestampRetrieved);\n\n    function getDataFeed(\n        bytes32 _feedId\n    ) external view returns (Autopay.FeedDetails memory);\n\n    function getFundedFeeds() external view returns (bytes32[] memory);\n\n    function getFundedQueryIds() external view returns (bytes32[] memory);\n\n    function getIndexForDataAfter(\n        bytes32 _queryId,\n        uint256 _timestamp\n    ) external view returns (bool _found, uint256 _index);\n\n    function getIndexForDataBefore(\n        bytes32 _queryId,\n        uint256 _timestamp\n    ) external view returns (bool _found, uint256 _index);\n\n    function getMultipleValuesBefore(\n        bytes32 _queryId,\n        uint256 _timestamp,\n        uint256 _maxAge,\n        uint256 _maxCount\n    )\n        external\n        view\n        returns (uint256[] memory _values, uint256[] memory _timestamps);\n\n    function getPastTipByIndex(\n        bytes32 _queryId,\n        uint256 _index\n    ) external view returns (Autopay.Tip memory);\n\n    function getPastTipCount(bytes32 _queryId) external view returns (uint256);\n\n    function getPastTips(\n        bytes32 _queryId\n    ) external view returns (Autopay.Tip[] memory);\n\n    function getQueryIdFromFeedId(\n        bytes32 _feedId\n    ) external view returns (bytes32);\n\n    function getRewardAmount(\n        bytes32 _feedId,\n        bytes32 _queryId,\n        uint256[] memory _timestamps\n    ) external view returns (uint256 _cumulativeReward);\n\n    function getRewardClaimedStatus(\n        bytes32 _feedId,\n        bytes32 _queryId,\n        uint256 _timestamp\n    ) external view returns (bool);\n\n    function getTipsByAddress(address _user) external view returns (uint256);\n\n    function isInDispute(\n        bytes32 _queryId,\n        uint256 _timestamp\n    ) external view returns (bool);\n\n    function queryIdFromDataFeedId(bytes32) external view returns (bytes32);\n\n    function queryIdsWithFunding(uint256) external view returns (bytes32);\n\n    function queryIdsWithFundingIndex(bytes32) external view returns (uint256);\n\n    function setupDataFeed(\n        bytes32 _queryId,\n        uint256 _reward,\n        uint256 _startTime,\n        uint256 _interval,\n        uint256 _window,\n        uint256 _priceThreshold,\n        uint256 _rewardIncreasePerSecond,\n        bytes memory _queryData,\n        uint256 _amount\n    ) external;\n\n    function tellor() external view returns (address);\n\n    function tip(\n        bytes32 _queryId,\n        uint256 _amount,\n        bytes memory _queryData\n    ) external;\n\n    function tips(\n        bytes32,\n        uint256\n    ) external view returns (uint256 amount, uint256 timestamp);\n\n    function token() external view returns (address);\n\n    function userTipsTotal(address) external view returns (uint256);\n\n    function valueFor(\n        bytes32 _id\n    )\n        external\n        view\n        returns (int256 _value, uint256 _timestamp, uint256 _statusCode);\n}\n\ninterface Autopay {\n    struct FeedDetails {\n        uint256 reward;\n        uint256 balance;\n        uint256 startTime;\n        uint256 interval;\n        uint256 window;\n        uint256 priceThreshold;\n        uint256 rewardIncreasePerSecond;\n        uint256 feedsWithFundingIndex;\n    }\n\n    struct Tip {\n        uint256 amount;\n        uint256 timestamp;\n    }\n\n    function getStakeAmount() external view returns (uint256);\n\n    function stakeAmount() external view returns (uint256);\n\n    function token() external view returns (address);\n}\n"
    },
    "contracts/tellor/TellorFlexOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ~0.8.17;\n\nimport {UsingTellor} from \"./UsingTellor.sol\";\n\nerror PriceOutdated();\n\ncontract TellorFlexOracle is UsingTellor {\n    constructor(address payable _tellorAddress) UsingTellor(_tellorAddress) {}\n\n    function latestAnswer() public view returns (int256) {\n        bytes memory _queryData = abi.encode(\n            \"SpotPrice\",\n            abi.encode(\"pls\", \"usd\")\n        );\n        bytes32 _queryId = keccak256(_queryData);\n\n        (bytes memory _value, uint256 _timestampRetrieved) = getDataBefore(\n            _queryId,\n            block.timestamp - 20 minutes\n        );\n        if (block.timestamp - _timestampRetrieved > 24 hours) {\n            revert PriceOutdated();\n        }\n\n        uint256 price = abi.decode(_value, (uint256));\n        // convert value to chainlink oracle format\n        return int256((price * 1e8) / 1e18);\n    }\n}\n"
    },
    "contracts/tellor/UsingTellor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./ITellor.sol\";\nimport \"./IERC2362.sol\";\nimport \"./IMappingContract.sol\";\n\n/**\n @author Tellor Inc\n @title UsingTellor\n @dev This contract helps smart contracts read data from Tellor\n */\ncontract UsingTellor is IERC2362 {\n    ITellor public tellor;\n    IMappingContract public idMappingContract;\n\n    /*Constructor*/\n    /**\n     * @dev the constructor sets the oracle address in storage\n     * @param _tellor is the Tellor Oracle address\n     */\n    constructor(address payable _tellor) {\n        tellor = ITellor(_tellor);\n    }\n\n    /*Getters*/\n    /**\n     * @dev Retrieves the next value for the queryId after the specified timestamp\n     * @param _queryId is the queryId to look up the value for\n     * @param _timestamp after which to search for next value\n     * @return _value the value retrieved\n     * @return _timestampRetrieved the value's timestamp\n     */\n    function getDataAfter(\n        bytes32 _queryId,\n        uint256 _timestamp\n    ) public view returns (bytes memory _value, uint256 _timestampRetrieved) {\n        (bool _found, uint256 _index) = getIndexForDataAfter(\n            _queryId,\n            _timestamp\n        );\n        if (!_found) {\n            return (\"\", 0);\n        }\n        _timestampRetrieved = getTimestampbyQueryIdandIndex(_queryId, _index);\n        _value = retrieveData(_queryId, _timestampRetrieved);\n        return (_value, _timestampRetrieved);\n    }\n\n    /**\n     * @dev Retrieves the latest value for the queryId before the specified timestamp\n     * @param _queryId is the queryId to look up the value for\n     * @param _timestamp before which to search for latest value\n     * @return _value the value retrieved\n     * @return _timestampRetrieved the value's timestamp\n     */\n    function getDataBefore(\n        bytes32 _queryId,\n        uint256 _timestamp\n    ) public view returns (bytes memory _value, uint256 _timestampRetrieved) {\n        (, _value, _timestampRetrieved) = tellor.getDataBefore(\n            _queryId,\n            _timestamp\n        );\n    }\n\n    /**\n     * @dev Retrieves latest array index of data before the specified timestamp for the queryId\n     * @param _queryId is the queryId to look up the index for\n     * @param _timestamp is the timestamp before which to search for the latest index\n     * @return _found whether the index was found\n     * @return _index the latest index found before the specified timestamp\n     */\n    // slither-disable-next-line calls-loop\n    function getIndexForDataAfter(\n        bytes32 _queryId,\n        uint256 _timestamp\n    ) public view returns (bool _found, uint256 _index) {\n        uint256 _count = getNewValueCountbyQueryId(_queryId);\n        if (_count == 0) return (false, 0);\n        _count--;\n        bool _search = true; // perform binary search\n        uint256 _middle = 0;\n        uint256 _start = 0;\n        uint256 _end = _count;\n        uint256 _timestampRetrieved;\n        // checking boundaries to short-circuit the algorithm\n        _timestampRetrieved = getTimestampbyQueryIdandIndex(_queryId, _end);\n        if (_timestampRetrieved <= _timestamp) return (false, 0);\n        _timestampRetrieved = getTimestampbyQueryIdandIndex(_queryId, _start);\n        if (_timestampRetrieved > _timestamp) {\n            // candidate found, check for disputes\n            _search = false;\n        }\n        // since the value is within our boundaries, do a binary search\n        while (_search) {\n            _middle = (_end + _start) / 2;\n            _timestampRetrieved = getTimestampbyQueryIdandIndex(\n                _queryId,\n                _middle\n            );\n            if (_timestampRetrieved > _timestamp) {\n                // get immediate previous value\n                uint256 _prevTime = getTimestampbyQueryIdandIndex(\n                    _queryId,\n                    _middle - 1\n                );\n                if (_prevTime <= _timestamp) {\n                    // candidate found, check for disputes\n                    _search = false;\n                } else {\n                    // look from start to middle -1(prev value)\n                    _end = _middle - 1;\n                }\n            } else {\n                // get immediate next value\n                uint256 _nextTime = getTimestampbyQueryIdandIndex(\n                    _queryId,\n                    _middle + 1\n                );\n                if (_nextTime > _timestamp) {\n                    // candidate found, check for disputes\n                    _search = false;\n                    _middle++;\n                    _timestampRetrieved = _nextTime;\n                } else {\n                    // look from middle + 1(next value) to end\n                    _start = _middle + 1;\n                }\n            }\n        }\n        // candidate found, check for disputed values\n        if (!isInDispute(_queryId, _timestampRetrieved)) {\n            // _timestampRetrieved is correct\n            return (true, _middle);\n        } else {\n            // iterate forward until we find a non-disputed value\n            while (\n                isInDispute(_queryId, _timestampRetrieved) && _middle < _count\n            ) {\n                _middle++;\n                _timestampRetrieved = getTimestampbyQueryIdandIndex(\n                    _queryId,\n                    _middle\n                );\n            }\n            if (\n                _middle == _count && isInDispute(_queryId, _timestampRetrieved)\n            ) {\n                return (false, 0);\n            }\n            // _timestampRetrieved is correct\n            return (true, _middle);\n        }\n    }\n\n    /**\n     * @dev Retrieves latest array index of data before the specified timestamp for the queryId\n     * @param _queryId is the queryId to look up the index for\n     * @param _timestamp is the timestamp before which to search for the latest index\n     * @return _found whether the index was found\n     * @return _index the latest index found before the specified timestamp\n     */\n    // slither-disable-next-line calls-loop\n    function getIndexForDataBefore(\n        bytes32 _queryId,\n        uint256 _timestamp\n    ) public view returns (bool _found, uint256 _index) {\n        return tellor.getIndexForDataBefore(_queryId, _timestamp);\n    }\n\n    /**\n     * @dev Retrieves multiple uint256 values before the specified timestamp\n     * @param _queryId the unique id of the data query\n     * @param _timestamp the timestamp before which to search for values\n     * @param _maxAge the maximum number of seconds before the _timestamp to search for values\n     * @param _maxCount the maximum number of values to return\n     * @return _values the values retrieved, ordered from oldest to newest\n     * @return _timestamps the timestamps of the values retrieved\n     */\n    function getMultipleValuesBefore(\n        bytes32 _queryId,\n        uint256 _timestamp,\n        uint256 _maxAge,\n        uint256 _maxCount\n    )\n        public\n        view\n        returns (bytes[] memory _values, uint256[] memory _timestamps)\n    {\n        // get index of first possible value\n        (bool _ifRetrieve, uint256 _startIndex) = getIndexForDataAfter(\n            _queryId,\n            _timestamp - _maxAge\n        );\n        // no value within range\n        if (!_ifRetrieve) {\n            return (new bytes[](0), new uint256[](0));\n        }\n        uint256 _endIndex;\n        // get index of last possible value\n        (_ifRetrieve, _endIndex) = getIndexForDataBefore(_queryId, _timestamp);\n        // no value before _timestamp\n        if (!_ifRetrieve) {\n            return (new bytes[](0), new uint256[](0));\n        }\n        uint256 _valCount = 0;\n        uint256 _index = 0;\n        uint256[] memory _timestampsArrayTemp = new uint256[](_maxCount);\n        // generate array of non-disputed timestamps within range\n        while (_valCount < _maxCount && _endIndex + 1 - _index > _startIndex) {\n            uint256 _timestampRetrieved = getTimestampbyQueryIdandIndex(\n                _queryId,\n                _endIndex - _index\n            );\n            if (!isInDispute(_queryId, _timestampRetrieved)) {\n                _timestampsArrayTemp[_valCount] = _timestampRetrieved;\n                _valCount++;\n            }\n            _index++;\n        }\n\n        bytes[] memory _valuesArray = new bytes[](_valCount);\n        uint256[] memory _timestampsArray = new uint256[](_valCount);\n        // retrieve values and reverse timestamps order\n        for (uint256 _i = 0; _i < _valCount; _i++) {\n            _timestampsArray[_i] = _timestampsArrayTemp[_valCount - 1 - _i];\n            _valuesArray[_i] = retrieveData(_queryId, _timestampsArray[_i]);\n        }\n        return (_valuesArray, _timestampsArray);\n    }\n\n    /**\n     * @dev Counts the number of values that have been submitted for the queryId\n     * @param _queryId the id to look up\n     * @return uint256 count of the number of values received for the queryId\n     */\n    function getNewValueCountbyQueryId(\n        bytes32 _queryId\n    ) public view returns (uint256) {\n        return tellor.getNewValueCountbyQueryId(_queryId);\n    }\n\n    /**\n     * @dev Returns the address of the reporter who submitted a value for a data ID at a specific time\n     * @param _queryId is ID of the specific data feed\n     * @param _timestamp is the timestamp to find a corresponding reporter for\n     * @return address of the reporter who reported the value for the data ID at the given timestamp\n     */\n    function getReporterByTimestamp(\n        bytes32 _queryId,\n        uint256 _timestamp\n    ) public view returns (address) {\n        return tellor.getReporterByTimestamp(_queryId, _timestamp);\n    }\n\n    /**\n     * @dev Gets the timestamp for the value based on their index\n     * @param _queryId is the id to look up\n     * @param _index is the value index to look up\n     * @return uint256 timestamp\n     */\n    function getTimestampbyQueryIdandIndex(\n        bytes32 _queryId,\n        uint256 _index\n    ) public view returns (uint256) {\n        return tellor.getTimestampbyQueryIdandIndex(_queryId, _index);\n    }\n\n    /**\n     * @dev Determines whether a value with a given queryId and timestamp has been disputed\n     * @param _queryId is the value id to look up\n     * @param _timestamp is the timestamp of the value to look up\n     * @return bool true if queryId/timestamp is under dispute\n     */\n    function isInDispute(\n        bytes32 _queryId,\n        uint256 _timestamp\n    ) public view returns (bool) {\n        return tellor.isInDispute(_queryId, _timestamp);\n    }\n\n    /**\n     * @dev Retrieve value from oracle based on queryId/timestamp\n     * @param _queryId being requested\n     * @param _timestamp to retrieve data/value from\n     * @return bytes value for query/timestamp submitted\n     */\n    function retrieveData(\n        bytes32 _queryId,\n        uint256 _timestamp\n    ) public view returns (bytes memory) {\n        return tellor.retrieveData(_queryId, _timestamp);\n    }\n\n    /**\n     * @dev allows dev to set mapping contract for valueFor (EIP2362)\n     * @param _addy address of mapping contract\n     */\n    function setIdMappingContract(address _addy) external {\n        require(address(idMappingContract) == address(0));\n        idMappingContract = IMappingContract(_addy);\n    }\n\n    /**\n     * @dev Retrieve most recent int256 value from oracle based on queryId\n     * @param _id being requested\n     * @return _value most recent value submitted\n     * @return _timestamp timestamp of most recent value\n     * @return _statusCode 200 if value found, 404 if not found\n     */\n    function valueFor(\n        bytes32 _id\n    )\n        external\n        view\n        override\n        returns (int256 _value, uint256 _timestamp, uint256 _statusCode)\n    {\n        bytes32 _queryId = idMappingContract.getTellorID(_id);\n        bytes memory _valueBytes;\n        (_valueBytes, _timestamp) = getDataBefore(\n            _queryId,\n            block.timestamp + 1\n        );\n        if (_timestamp == 0) {\n            return (0, 0, 404);\n        }\n        uint256 _valueUint = _sliceUint(_valueBytes);\n        _value = int256(_valueUint);\n        return (_value, _timestamp, 200);\n    }\n\n    // Internal functions\n    /**\n     * @dev Convert bytes to uint256\n     * @param _b bytes value to convert to uint256\n     * @return _number uint256 converted from bytes\n     */\n    function _sliceUint(\n        bytes memory _b\n    ) internal pure returns (uint256 _number) {\n        for (uint256 _i = 0; _i < _b.length; _i++) {\n            _number = _number * 256 + uint8(_b[_i]);\n        }\n    }\n\n    /**\n     * @dev Allows the user to get the latest value for the queryId specified\n     * @param _queryId is the id to look up the value for\n     * @return _ifRetrieve bool true if non-zero value successfully retrieved\n     * @return _value the value retrieved\n     * @return _timestampRetrieved the retrieved value's timestamp\n     */\n    function getCurrentValue(\n        bytes32 _queryId\n    )\n        public\n        view\n        returns (\n            bool _ifRetrieve,\n            bytes memory _value,\n            uint256 _timestampRetrieved\n        )\n    {\n        uint256 _count = tellor.getNewValueCountbyQueryId(_queryId);\n        if (_count == 0) {\n            return (false, bytes(\"\"), 0);\n        }\n        uint256 _time = tellor.getTimestampbyQueryIdandIndex(\n            _queryId,\n            _count - 1\n        );\n        _value = tellor.retrieveData(_queryId, _time);\n        if (keccak256(_value) != keccak256(bytes(\"\")))\n            return (true, _value, _time);\n        return (false, bytes(\"\"), _time);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1300
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}